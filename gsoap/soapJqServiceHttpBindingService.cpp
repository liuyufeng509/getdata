/* soapJqServiceHttpBindingService.cpp
   Generated by gSOAP 2.8.30 for getdata.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include "soapJqServiceHttpBindingService.h"

JqServiceHttpBindingService::JqServiceHttpBindingService() : soap(SOAP_IO_DEFAULT)
{	JqServiceHttpBindingService_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

JqServiceHttpBindingService::JqServiceHttpBindingService(const JqServiceHttpBindingService& rhs)
{	soap_copy_context(this, &rhs);
}

JqServiceHttpBindingService::JqServiceHttpBindingService(const struct soap &_soap) : soap(_soap)
{ }

JqServiceHttpBindingService::JqServiceHttpBindingService(soap_mode iomode) : soap(iomode)
{	JqServiceHttpBindingService_init(iomode, iomode);
}

JqServiceHttpBindingService::JqServiceHttpBindingService(soap_mode imode, soap_mode omode) : soap(imode, omode)
{	JqServiceHttpBindingService_init(imode, omode);
}

JqServiceHttpBindingService::~JqServiceHttpBindingService()
{
	this->destroy();
}

void JqServiceHttpBindingService::JqServiceHttpBindingService_init(soap_mode imode, soap_mode omode)
{	soap_imode(this, imode);
	soap_omode(this, omode);
	static const struct Namespace namespaces[] = {
        {"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
        {"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
        {"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
        {"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
        {"ns1", "SampleServices", NULL, NULL},
        {NULL, NULL, NULL, NULL}
    };
	soap_set_namespaces(this, namespaces);
}

void JqServiceHttpBindingService::destroy()
{	soap_destroy(this);
	soap_end(this);
}

void JqServiceHttpBindingService::reset()
{	this->destroy();
	soap_done(this);
	soap_initialize(this);
	JqServiceHttpBindingService_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

#ifndef WITH_PURE_VIRTUAL
JqServiceHttpBindingService *JqServiceHttpBindingService::copy()
{	JqServiceHttpBindingService *dup = SOAP_NEW_COPY(JqServiceHttpBindingService(*(struct soap*)this));
	return dup;
}
#endif

JqServiceHttpBindingService& JqServiceHttpBindingService::operator=(const JqServiceHttpBindingService& rhs)
{	soap_copy_context(this, &rhs);
	return *this;
}

int JqServiceHttpBindingService::soap_close_socket()
{	return soap_closesock(this);
}

int JqServiceHttpBindingService::soap_force_close_socket()
{	return soap_force_closesock(this);
}

int JqServiceHttpBindingService::soap_senderfault(const char *string, const char *detailXML)
{	return ::soap_sender_fault(this, string, detailXML);
}

int JqServiceHttpBindingService::soap_senderfault(const char *subcodeQName, const char *string, const char *detailXML)
{	return ::soap_sender_fault_subcode(this, subcodeQName, string, detailXML);
}

int JqServiceHttpBindingService::soap_receiverfault(const char *string, const char *detailXML)
{	return ::soap_receiver_fault(this, string, detailXML);
}

int JqServiceHttpBindingService::soap_receiverfault(const char *subcodeQName, const char *string, const char *detailXML)
{	return ::soap_receiver_fault_subcode(this, subcodeQName, string, detailXML);
}

void JqServiceHttpBindingService::soap_print_fault(FILE *fd)
{	::soap_print_fault(this, fd);
}

#ifndef WITH_LEAN
#ifndef WITH_COMPAT
void JqServiceHttpBindingService::soap_stream_fault(std::ostream& os)
{	::soap_stream_fault(this, os);
}
#endif

char *JqServiceHttpBindingService::soap_sprint_fault(char *buf, size_t len)
{	return ::soap_sprint_fault(this, buf, len);
}
#endif

void JqServiceHttpBindingService::soap_noheader()
{	this->header = NULL;
}

::SOAP_ENV__Header *JqServiceHttpBindingService::soap_header()
{	return this->header;
}

int JqServiceHttpBindingService::run(int port)
{	if (!soap_valid_socket(this->master) && !soap_valid_socket(this->bind(NULL, port, 100)))
		return this->error;
	for (;;)
	{	if (!soap_valid_socket(this->accept()))
		{	if (this->errnum == 0) // timeout?
				this->error = SOAP_OK;
			break;
		}
		if (this->serve())
			break;
		this->destroy();
	}
	return this->error;
}

#if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
int JqServiceHttpBindingService::ssl_run(int port)
{	if (!soap_valid_socket(this->master) && !soap_valid_socket(this->bind(NULL, port, 100)))
		return this->error;
	for (;;)
	{	if (!soap_valid_socket(this->accept()))
		{	if (this->errnum == 0) // timeout?
				this->error = SOAP_OK;
			break;
		}
		if (this->ssl_accept() || this->serve())
			break;
		this->destroy();
	}
	return this->error;
}
#endif

SOAP_SOCKET JqServiceHttpBindingService::bind(const char *host, int port, int backlog)
{	return soap_bind(this, host, port, backlog);
}

SOAP_SOCKET JqServiceHttpBindingService::accept()
{	return soap_accept(this);
}

#if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
int JqServiceHttpBindingService::ssl_accept()
{	return soap_ssl_accept(this);
}
#endif

int JqServiceHttpBindingService::serve()
{
#ifndef WITH_FASTCGI
	unsigned int k = this->max_keep_alive;
#endif
	do
	{

#ifndef WITH_FASTCGI
		if (this->max_keep_alive > 0 && !--k)
			this->keep_alive = 0;
#endif

		if (soap_begin_serve(this))
		{	if (this->error >= SOAP_STOP)
				continue;
			return this->error;
		}
		if (dispatch() || (this->fserveloop && this->fserveloop(this)))
		{
#ifdef WITH_FASTCGI
			soap_send_fault(this);
#else
			return soap_send_fault(this);
#endif
		}

#ifdef WITH_FASTCGI
		soap_destroy(this);
		soap_end(this);
	} while (1);
#else
	} while (this->keep_alive);
#endif
	return SOAP_OK;
}

static int serve___ns1__getData(JqServiceHttpBindingService*);

int JqServiceHttpBindingService::dispatch()
{
	soap_peek_element(this);
	if (!soap_match_tag(this, this->tag, "ns1:getData"))
		return serve___ns1__getData(this);
	return this->error = SOAP_NO_METHOD;
}

static int serve___ns1__getData(JqServiceHttpBindingService *soap)
{	struct __ns1__getData soap_tmp___ns1__getData;
	ns1__getDataResponse ns1__getDataResponse_;
	ns1__getDataResponse_.soap_default(soap);
	soap_default___ns1__getData(soap, &soap_tmp___ns1__getData);
	if (!soap_get___ns1__getData(soap, &soap_tmp___ns1__getData, "-ns1:getData", NULL))
		return soap->error;
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap->error = soap->getData(soap_tmp___ns1__getData.ns1__getData_, ns1__getDataResponse_);
	if (soap->error)
		return soap->error;
	soap->encodingStyle = NULL;
	soap_serializeheader(soap);
	ns1__getDataResponse_.soap_serialize(soap);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || ns1__getDataResponse_.soap_put(soap, "ns1:getDataResponse", "")
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	};
	if (soap_end_count(soap)
	 || soap_response(soap, SOAP_OK)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || ns1__getDataResponse_.soap_put(soap, "ns1:getDataResponse", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap->error;
	return soap_closesock(soap);
}
/* End of server object code */
